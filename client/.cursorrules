You are an expert in TypeScript, Node.js, Vite, Vue.js, Vue Router, Pinia, VueUse, Headless UI, Element Plus, and Tailwind, with a deep understanding of best practices and performance optimization techniques in these technologies.

Code Style and Structure

- Write concise, maintainable, and technically accurate TypeScript code with relevant examples.
- Use functional and declarative programming patterns; avoid classes.
- Favor iteration and modularization to adhere to DRY principles and avoid code duplication.
- Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError).
- Organize files systematically: each file should contain only related content, such as exported components, subcomponents, helpers, static content, and types.

Naming Conventions

- Use lowercase with dashes for directories (e.g., components/auth-wizard).
- Favor named exports for functions.

TypeScript Usage

- Use TypeScript for all code; prefer interfaces over types for their extendability and ability to merge.
- Avoid enums; use maps instead for better type safety and flexibility.
- Use functional components with TypeScript interfaces.

Syntax and Formatting

- Use the "function" keyword for pure functions to benefit from hoisting and clarity.
- Always place the template section first in a component file.
- Always use the Vue Composition API script setup style.

UI and Styling

- Use Headless UI, Element Plus, and Tailwind for components and styling.
- Implement responsive design with Tailwind CSS; use a mobile-first approach.

Performance Optimization

- Leverage VueUse functions where applicable to enhance reactivity and performance.
- Wrap asynchronous components in Suspense with a fallback UI.
- Use dynamic loading for non-critical components.
- Optimize images: use WebP format, include size data, implement lazy loading.
- Implement an optimized chunking strategy during the Vite build process, such as code splitting, to generate smaller bundle sizes.

Key Conventions

- Optimize Web Vitals (LCP, CLS, FID) using tools like Lighthouse or WebPageTest.

Domain-Driven Architecture

- Organize code by business domains (e.g., /domains/npanxx, /domains/az)
- Each domain should be self-contained with its own:
  - types/
  - components/
  - services/
  - store/
  - utils/
- Cross-domain functionality should be in shared/ domain
- Composables should be domain-aware and use appropriate domain stores/services
- Keep domain-specific types and logic within their respective domains
- Use shared/types for cross-domain interfaces and types

Git Commits

- Use the imperative mood in the commit message
- Use the present tense in the commit message
- Keep commits to 50 characters or less
- Use FEAT: for feature commits
- Use FIX: for bug fix commits
- Use DOCS: for documentation commits
- Use STYLE: for style commits
- Use REFACTOR: for refactoring commits
- Use PERF: for performance commits
- Use TEST: for testing commits
- Use CHORE: for chore commits
