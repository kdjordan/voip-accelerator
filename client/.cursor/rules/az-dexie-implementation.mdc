---
description: Comprehensive implementation plan for refactoring AZ rate deck uploads to use Dexie storage
globs: 
alwaysApply: false
---
---
description: Simplified implementation plan for AZ rate deck storage using Dexie directly
globs: 
alwaysApply: false
---

# Simplified AZ Rate Deck Dexie Implementation

## Overview
This document outlines a simplified approach to refactor the AZ rate deck uploads to use Dexie.js directly for local storage, eliminating the complex storage service abstraction layers.

## Current Issues

1. Over-engineered storage abstraction with multiple strategy patterns
2. Unnecessary complexity with conditional logic for different storage types
3. Indirect access to Dexie through multiple layers
4. No session cleanup for IndexedDB on page unload

## Simplified Implementation

### 1. Direct Dexie Integration in AZService

**File**: `client/src/services/az.service.ts`

```typescript
import { type AZStandardizedData, type InvalidAzRow } from '@/types/domains/az-types';
import { DBName } from '@/types/app-types';
import { useAzStore } from '@/stores/az-store';
import Papa from 'papaparse';
import useDexieDB from '@/composables/useDexieDB'; // Direct import of Dexie composable

export class AZService {
  private store = useAzStore();

  constructor() {
    console.log('Initializing simplified AZ service');
  }

  // Process file and store directly in Dexie
  async processFile(
    file: File,
    columnMapping: Record<string, number>,
    startLine: number
  ): Promise<{ fileName: string; records: AZStandardizedData[] }> {
    const tableName = file.name.toLowerCase().replace('.csv', '');
    const { storeInDexieDB } = useDexieDB();
    
    // Clear any existing invalid rows for this file
    this.store.clearInvalidRowsForFile(file.name);

    return new Promise((resolve, reject) => {
      Papa.parse(file, {
        header: false,
        skipEmptyLines: true,
        complete: async (results: { data: string[][] }) => {
          try {
            // Skip to user-specified start line
            const dataRows = results.data.slice(startLine - 1);
            const validRecords: AZStandardizedData[] = [];

            dataRows.forEach((row, index) => {
              const destName = row[columnMapping.destination]?.trim() || '';
              const dialCode = row[columnMapping.dialcode]?.trim() || '';
              const rateStr = row[columnMapping.rate];
              const rate = parseFloat(rateStr);

              // Validate the rate - if not a valid number, add to invalid rows
              if (isNaN(rate) || !destName || !dialCode) {
                const invalidRow: InvalidAzRow = {
                  rowIndex: startLine + index,
                  destName,
                  dialCode,
                  invalidRate: rateStr || '',
                  reason: isNaN(rate)
                    ? 'Invalid rate'
                    : !destName
                    ? 'Missing destination name'
                    : 'Missing dial code',
                };
                this.store.addInvalidRow(file.name, invalidRow);
              } else {
                validRecords.push({
                  destName,
                  dialCode,
                  rate,
                });
              }
            });

            // Store directly in Dexie - no storage strategy conditional logic
            if (validRecords.length > 0) {
              await storeInDexieDB(validRecords, DBName.AZ, tableName);
              console.log(`[AZService] Stored ${validRecords.length} records in Dexie for table: ${tableName}`);
            }

            this.store.addFileUploaded(file.name, tableName);

            // Determine component ID for file stats
            let componentId = '';
            if (this.store.getFileNameByComponent('az1') === file.name) {
              componentId = 'az1';
            } else if (this.store.getFileNameByComponent('az2') === file.name) {
              componentId = 'az2';
            } else {
              componentId = this.store.getFileNameByComponent('az1') ? 'az2' : 'az1';
            }

            // Calculate and store file stats
            await this.calculateFileStats(componentId, file.name);

            resolve({ fileName: file.name, records: validRecords });
          } catch (error) {
            reject(error);
          }
        },
        error: (error) => reject(new Error(`Failed to process CSV: ${error.message}`)),
      });
    });
  }

  // Get data directly from Dexie
  async getData(tableName: string): Promise<AZStandardizedData[]> {
    try {
      const { loadFromDexieDB } = useDexieDB();
      const data = await loadFromDexieDB<AZStandardizedData>(DBName.AZ, tableName);
      console.log(`[AZService] Retrieved ${data.length} records from Dexie table: ${tableName}`);
      return data;
    } catch (error) {
      console.error(`Failed to get data from table ${tableName}:`, error);
      throw error;
    }
  }

  // Calculate file statistics
  async calculateFileStats(componentId: string, fileName: string): Promise<void> {
    try {
      const tableName = fileName.toLowerCase().replace('.csv', '');
      const data = await this.getData(tableName);

      if (!data || data.length === 0) return;

      // Calculate stats
      const totalCodes = data.length;
      const uniqueDestinations = new Set(data.map((item) => item.destName)).size;
      const uniquePercentage = ((uniqueDestinations / totalCodes) * 100).toFixed(2);

      // Update store
      this.store.setFileStats(componentId, {
        totalCodes,
        totalDestinations: uniqueDestinations,
        uniqueDestinationsPercentage: parseFloat(uniquePercentage),
      });
    } catch (error) {
      console.error('Error calculating file stats:', error);
    }
  }

  // Remove a table directly from Dexie
  async removeTable(tableName: string): Promise<void> {
    try {
      // Find the component ID associated with this table
      const fileName = tableName + '.csv';
      let componentId = '';

      if (this.store.getFileNameByComponent('az1') === fileName) {
        componentId = 'az1';
      } else if (this.store.getFileNameByComponent('az2') === fileName) {
        componentId = 'az2';
      }

      if (componentId) {
        // Clear file stats for this component
        this.store.clearFileStats(componentId);
      }

      // Use DexieDB directly
      const { getDB } = useDexieDB();
      const db = await getDB(DBName.AZ);
      
      if (db.hasStore(tableName)) {
        await db.deleteStore(tableName);
        console.log(`Table ${tableName} removed successfully from Dexie`);
      }
    } catch (error) {
      console.error(`Failed to remove table ${tableName}:`, error);
      throw error;
    }
  }

  // Clear all AZ data
  async clearData(): Promise<void> {
    try {
      const { deleteDatabase } = useDexieDB();
      await deleteDatabase(DBName.AZ);
      console.log('[AZService] Cleared all Dexie data for AZ');
      
      // Reset the file tracking in the store
      this.store.resetFiles();
    } catch (error) {
      console.error('Failed to clear AZ data:', error);
      throw error;
    }
  }

  // Get record count for a table
  async getRecordCount(tableName: string): Promise<number> {
    try {
      const { getDB } = useDexieDB();
      const db = await getDB(DBName.AZ);
      
      if (db.hasStore(tableName)) {
        const count = await db.table(tableName).count();
        console.log(`[AZService] Count for Dexie table ${tableName}: ${count}`);
        return count;
      }
      return 0;
    } catch (error) {
      console.error(`Failed to get record count for table ${tableName}:`, error);
      return 0;
    }
  }
}
```

### 2. Simplify Sample Data Loading

**File**: `client/src/utils/load-sample-data.ts`

```typescript
export async function loadSampleDecks(dbNames: DBNameType[]): Promise<void> {
  try {
    console.log('Starting sample deck loading for:', dbNames);

    if (dbNames.includes(DBName.AZ)) {
      const azService = new AZService();
      
      // Load AZ-Test1.csv data
      const azTestFile = 'AZ-Test1.csv';
      const azTestResponse = await fetch(`/src/data/sample/${azTestFile}`);
      const azTestBlob = new File([await azTestResponse.blob()], azTestFile);

      // Column mapping structure for AZService
      const columnMapping = {
        destination: 0, // Index of destination column
        dialcode: 1,    // Index of dialcode column
        rate: 2,        // Index of rate column
      };

      try {
        const result = await azService.processFile(azTestBlob, columnMapping, 1);
        console.log(`Sample data loaded for ${azTestFile}: ${result.records.length} records`);
      } catch (error) {
        console.error(`Error loading sample data for ${azTestFile}:`, error);
      }

      // Load AZ-Test2.csv data
      const azTest2File = 'AZ-Test2.csv';
      const azTest2Response = await fetch(`/src/data/sample/${azTest2File}`);
      const azTest2Blob = new File([await azTest2Response.blob()], azTest2File);

      try {
        const result2 = await azService.processFile(azTest2Blob, columnMapping, 1);
        console.log(`Sample data loaded for ${azTest2File}: ${result2.records.length} records`);
      } catch (error) {
        console.error(`Error loading sample data for ${azTest2File}:`, error);
      }
    }

    // US deck loading would follow a similar pattern
    if (dbNames.includes(DBName.US)) {
      // Similar implementation for US decks
    }

    console.log('Sample decks loaded successfully');
  } catch (error) {
    console.error('Error loading sample decks:', error);
    throw error;
  }
}
```

### 3. Implement Session Cleanup

**File**: `client/src/main.ts` or `client/src/App.vue`

```typitten
import { cleanupDatabases } from '@/utils/cleanup';

// Add event listener for page unload to clean up databases
window.addEventListener('beforeunload', async () => {
  console.log('Page unloading, cleaning up databases...');
  await cleanupDatabases();
});
```

## Benefits of This Approach

1. **Simplicity**: Direct use of Dexie without abstraction layers
2. **Maintainability**: Less code, fewer places for bugs to hide
3. **Performance**: Fewer function calls and transformations
4. **Clarity**: Clear intent in code, easy to follow data flow

## Implementation Steps

1. Update AZService to use Dexie directly (1 day)
2. Update loadSampleDecks function (0.5 day)
3. Add cleanup logic (0.5 day)
4. Testing (1 day)

## Testing Strategy

### 1. Verify Data Storage
- Upload files through UI
- Check that data is stored in IndexedDB
- Verify all data can be retrieved

### 2. Test Session Cleanup
- Verify databases are cleaned up on page unload
- Check for any memory leaks

## Key Points for Implementation

1. Use `useDexieDB()` composable directly in services
2. No conditional logic for storage strategy
3. Clear error handling and logging
4. Keep the AZ store for UI state management 